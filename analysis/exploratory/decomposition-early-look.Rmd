---
title: "WMATA Queue Jump Effectiveness: First Look at Early Decomposition Values"
output: 
  html_notebook:
    toc: true
    toc_depth: 2
    toc_float: yes
    df_print: paged
    number_sections: false
    theme: simplex
---

This notebook examines the outputs of the `wmatarawnav` Python package and QJ Effectiveness study code for the October 2019 period on various study routes and segments. This notebook does not present a complete decomposition of runs, but presents some of the inputs that will feed into the decomposition calculation. Later, relevant parts of this analysis will be done in Python, but are done in R here to speed up certain analysis and visualization tasks.

```{r message=FALSE, warning=FALSE}
# Environment setup
library(tidyverse)
library(plotly)
library(sf)
library(mapview)
library(leaflet)
library(patchwork)

set.seed(1)

if (any(Sys.info() =="WylieTimmerman")){
  path_project <- "C:/Users/WylieTimmerman/Documents/projects_local/wmata_avl_local"  
} else {
  stop('set paths')
}

path_data <- file.path(path_project,"data","02-processed","rawnav_stop_areas")

```


# Freeflow Speeds
We'll take a first look at freeflow speeds by segment. First, speeds were calculated between each rawnav ping and a ping three pings later (for a total of three intervals between four points). These speeds were calculated on a rolling basis, such that the interval between two rawnav pings may be reflected in several speed values. Any speed values above 50 mph were excluded from the percentile calculations. In the table below, speeds are sorted in descending order based on the 95th percentile.
```{r message=FALSE, warning=FALSE}
freeflow <- read_csv(file = file.path(path_data,"freeflow.csv"),
                     col_types = cols(
                       X1 = col_double(),
                       ntile = col_double(),
                       fps_next3 = col_double(),
                       mph = col_double(),
                       seg_name_id = col_character()
                     )) %>%
  select(-X1)

freeflow_spread <-
  freeflow %>%
  select(-fps_next3) %>%
  filter(ntile %in% c(.25,.5,.75,.9,.95,.99)) %>%
  mutate(mph = round(mph)) %>%
  pivot_wider(id_cols = seg_name_id, names_from = ntile, values_from = mph) %>%
  arrange(desc(`0.95`))

freeflow_spread
```

So far, these seem plausible. 

# Data Load 

Though the Python code generates summaries of freeflow speeds, tstop1 (door open time), and other decomposition inputs (accel time, decel time, etc.), below we'll look at the underlying rawnav pings *within stop areas (+/- 150 feet around a stop)*. We'll load all evaluation segments except for Georgia and Irving and exclude a few runs that have extremely high values. Currently, the Georgia-Irving case where Route 70 serves two stops, a special case not yet handled in the processing code. 
```{r message=FALSE, warning=FALSE}

filelist <- list.files(path_data, pattern = "ourpoints", full.names = TRUE)

filelist_named <- set_names(filelist,
                            nm = str_match(filelist,"ourpoints_([\\s\\S]*).csv$")[,2])

rawnav_stop_area_raw <- 
  imap_dfr(filelist_named,
           ~ readr::read_csv(.x,
                             col_types =  cols(
                               X1 = col_double(),
                               index = col_double(),
                               index_loc = col_double(),
                               lat = col_double(),
                               long = col_double(),
                               heading = col_double(),
                               door_state = col_character(),
                               veh_state = col_character(),
                               odom_ft = col_double(),
                               sec_past_st = col_double(),
                               stop_window = col_character(),
                               row_before_apc = col_double(),
                               route_pattern = col_character(),
                               pattern = col_double(),
                               index_run_start = col_double(),
                               index_run_end = col_double(),
                               filename = col_character(),
                               start_date_time = col_datetime(format = ""),
                               route = col_double(),
                               wday = col_character(),
                               odom_ft_qj_stop = col_double(),
                               stop_id = col_double(),
                               odom_ft_next = col_double(),
                               sec_past_st_next = col_double(),
                               odom_ft_next3 = col_double(),
                               sec_past_st_next3 = col_double(),
                               fps_next = col_double(),
                               fps_next3 = col_double(),
                               secs_marg = col_double(),
                               odom_ft_marg = col_double(),
                               door_state_closed = col_logical(),
                               veh_state_moving = col_logical(),
                               veh_state_changes = col_double(),
                               door_state_changes = col_double(),
                               rough_state = col_character(),
                               at_stop = col_logical(),
                               at_stop_state = col_logical(),
                               stop_area_phase = col_character()
                             )),
           .id = "seg_name_id"
  )
  
# some light calculation of fields and filtering
rawnav_stop_area <-
  rawnav_stop_area_raw %>%
  unite(busrun, filename, index_run_start, remove = FALSE) %>%
  mutate(mph_next = fps_next / 1.467,
         mph_next3 = fps_next3 / 1.467) %>%
  mutate(stop_area_phase = factor(stop_area_phase,
                                  levels = c("t_decel_phase",
                                             "t_l_initial",
                                             "t_stop1",
                                             "t_stop",
                                             "t_l_addl",
                                             "t_accel_phase",
                                             "t_nostopnopax",
                                             "t_nopax"))) %>%
  group_by(busrun, seg_name_id) %>%
  mutate(odom_ft_stop_area = odom_ft - min(odom_ft),
         secs_stop_area = sec_past_st - min(sec_past_st)) %>%
  # there also issues with odometer resets in some cases
  filter(max(secs_stop_area) < 500) %>%
  ungroup() %>%
  # issues with this one b/c of multiple stops, setting aside for now
  filter(seg_name_id != "georgia_irving")

```

Briefly, what does our data look like?

```{r}
rawnav_stop_area %>%
  glimpse()
```

Across all our segments, how long does a bus spend in each zone, excluding runs that go straight through without opening doors to pick up passengers and those that stop but don't pick up passengers? 
```{r}
rawnav_stop_area %>%
  group_by(busrun,seg_name_id) %>%
  filter(any_veh_stopped & any_door_open) %>% 
  group_by(busrun, seg_name_id, stop_area_phase) %>%
  summarize(tot_secs = sum(secs_marg, na.rm = TRUE)) %>%
  group_by(stop_area_phase) %>% 
  summarize(avg_seconds = mean(tot_secs, na.rm = TRUE))
```

So far, this seems plausible. A few terms are worth defining. Collectively, these comprehensively describe the sequence a typical bus run will undergo in a stop area:

* t_decel_phase: time from entering the stop area until the bus reaches a stop and is about to open its doors.
* t_l_initial: lost time where the bus is stopped at the stop but the doors are still closed. 
* t_stop1: time where the bus has its doors open. If the doors are closed and reopened, subsequent door open times are *not* included in this value.
* t_l_addl: additional lost time between the closing of the doors in t_stop1 until the vehicle begins to move and depart the stop zone. Notably, if a vehicle opens its doors, closes them, moves forward slightly, and then reopens its doors and re-closes them, the extra time spent opening and cl
* t_accel_phase: the time after the last door closure through the acceleration phase to the end of the stop area.

Notably, runs that do not open their doors to passengers are categorized as "t_nostop" throughout.

We can visualize these phases for a single trip. Again, this does not reflect the final decomposition (t_stop2 calculations are still to be made), but help to indicate how these values are shaping up. 

```{r}
make_basic_timespace <- function(df){
  ggplot(df,
         aes(x = secs_stop_area, 
             y = odom_ft_stop_area, 
             color = stop_area_phase,
             group = busrun,
             label = stop_area_phase)) + 
    geom_line(alpha = 1, size = 2) + 
    scale_y_continuous(labels = scales::comma,
                       name = "Dist (ft) in Stop Area") +
    scale_x_continuous(labels = scales::comma,
                       name = "Time (secs) in Stop Area") +
    scale_color_manual(
      values = c(
        "t_decel_phase" = "#D7191C",
        "t_l_initial" = "#FDAE61",
        "t_stop1" = "#FFFFBF",
        "t_l_addl" = "#A6D96A",
        "t_accel_phase" = "#1A9641",
        "t_nostop" = "#6a3d9a"
      )
    ) +
    guides(color = guide_legend( direction = "horizontal",
                                 nrow = 2,
                                 title = NULL,
                                 byrow = TRUE)) +
    theme(legend.position = "top")
}

singleline <- 
  rawnav_stop_area %>%
  filter(busrun == "rawnav02805191009.txt_1528", seg_name_id == "georgia_columbia") %>%
  make_basic_timespace()


singleline
```


Are there cases of reopening doors in our dataset? Yes. 
```{r}
rawnav_stop_area %>% 
  group_by(busrun,seg_name_id) %>%
  # Door_state_changes is a special var that increments every time the door state changes
  # and is better than just counting rows with door_state = "O". We have 
  # to do a little more work though to get a count of values, however.
  summarize(tot_changes = max(door_state_changes)) %>% 
  mutate(openings = (tot_changes - 1)/2) %>%
  pull(openings) %>%
  summary()
```
Most buses will open their doors just once, but there's a long tail to the right.

This is the total number of run-segment combinations with no openings...
```{r}
runs_w_no_openings <- 
  rawnav_stop_area %>% 
  group_by(busrun, seg_name_id) %>%
  filter(max(door_state_changes) ==1) %>%
  distinct(busrun)

nrow(runs_w_no_openings)
```
...out of ...

```{r}
distinct(rawnav_stop_area,busrun, seg_name_id) %>%
  nrow()
```
Around `r scales::percent((nrow(runs_w_no_openings)/nrow(distinct(rawnav_stop_area,busrun,seg_name_id))))` of runs! This seems pretty high! Why might this be? 

So we see both many runs with no door openings and some with several. What's the distribution? 

```{r message=FALSE, warning=FALSE}
run_openings <- 
  rawnav_stop_area %>% 
  group_by(seg_name_id,busrun) %>%
  summarize(openings = max(door_state_changes)) %>% 
  mutate(openings = (openings - 1)/2)

binw = 1

ggplot(run_openings, aes(x = openings)) + 
  geom_histogram() +
  geom_histogram(aes(fill=seg_name_id), binwidth=binw, colour="grey20", lwd=0.2) +
  stat_bin(binwidth=binw, geom="text", colour="white", size=3.5,
           aes(label=scales::comma(..count.., accuracy = 1), group=seg_name_id), 
           position=position_stack(vjust=0.5)) +
  scale_x_continuous(breaks=seq(-1,7, binw), limits = c(-1,7))
```

# Examining Georgia-Columbia

Let's look at Georgia-Columbia on the 79 as we dive into the data more deeply.

Here we replicate the speed by distance chart from earlier notebooks, but focus on only the stop area (for each run, +/- 150 feet around the a rawnav ping nearest to the stop). All run odometer distances are set such that the rawnav point nearest a stop comes at 150 ft. We see that some of these runs come to a stop before the 150 ft mark. This could be the result of several things:

* Buses are pulling up a little shy of the stop itself to let passengers on and off. This could be the case if a vehicle is in the bus zone.
* Buses are stopping short of the bus zone and then edging forward at slow speeds to the bus zone. 
* The rawnav ping nearest the bus stop will in fact vary slightly by run, such that for some this ping is slightly downstream of the stop and for others it is slightly upstream. Collectively, this would result in a larger 'spread ' of lines around the stop. This latter point has implications for ideas to automatically 'detect' a stop location that are not discussed here.
```{r}
plot <-
  rawnav_stop_area %>%
  filter(seg_name_id == "georgia_columbia") %>%
  plotly::highlight_key(., ~busrun) %>%
  ggplot(.,
         aes(x = odom_ft_stop_area, y = mph_next3, group = busrun)) + 
  geom_line(alpha = .1) + 
  scale_x_continuous(labels = scales::comma) +
  labs(x = "Distance Traveled (ft) in Stop Area", y = "Speed (mph) over next 3 observations")

plot %>% ggplotly(tooltip = "busrun")

```

The spacetime diagrams tell a similar story, with a few exceptions.

* It's more apparent that some bus runs do not let passengers alight at all and proceed directly along in a straight vertical line. * Some runs are dwelling at the stop for a considerable amount of time. Note that runs with stop area travel time above 500 seconds are removed from this dataset.


```{r}
stringline <- 
  rawnav_stop_area %>%
  filter(seg_name_id == "georgia_columbia") %>%
  ggplot(.,
         aes(x = secs_stop_area, 
             y = odom_ft_stop_area, 
             group = busrun)) + 
  geom_line(alpha = .1) + 
  scale_y_continuous(labels = scales::comma,
                     name = "Distance Traveled (ft) in Stop Area") +
  scale_x_continuous(labels = scales::comma,
                     name = "Time (secs) in Stop Area") 

stringline
```
Let's look once more at our speed over distance chart, with the added benefit of colors
```{r}
make_basic_speeddist <- function(df, alpha = .1, size = 1, lt = "solid", legend = "right"){
  ggplot(df,
         aes(x = odom_ft_stop_area,
             y = mph_next3, 
             group = busrun, 
             color = stop_area_phase)) + 
    geom_line(alpha = alpha, 
              size = size,
              linetype = lt) + 
    scale_color_manual(
      values = c(
        "t_decel_phase" = "#D7191C",
        "t_l_initial" = "#FDAE61",
        "t_stop1" = "#FFFFBF",
        "t_stop" = "#FFFFBF",
        "t_l_addl" = "#A6D96A",
        "t_accel_phase" = "#1A9641",
        "t_nostopnopax" = "#6a3d9a"
      )
    ) + 
    scale_x_continuous(labels = scales::comma) +
    scale_y_continuous(limits = c(0, 40), n.breaks = 5) +
    labs(x = "Dist. (ft) in Stop Area",
         y = "Speed (mph) next 3 obs.") +
    guides(color = guide_legend(reverse = TRUE)) +
    theme(legend.position = legend)
  
}

plot_color <-
  rawnav_stop_area %>%
  filter(seg_name_id == "georgia_columbia") %>%
  plotly::highlight_key(., ~busrun) %>%
  make_basic_speeddist()

plot_color
```
  

## Decomposition

We continue with a decomposition based on the inputs thus far. For now, we dump this code in, will break out components and discuss later.

```{r}
freeflow_to_join <-
  freeflow %>%
  filter(ntile == .95) %>%
  select(seg_name_id,
         freeflow_fps = fps_next3)

# Let's add in the decel phase here instead
no_stop_decomp <-
  rawnav_stop_area %>%
  # Though we're not expecting to find other values in this category, we'll 
  # be a little careful still
  group_by(busrun, seg_name_id) %>%
  filter(stop_area_phase %in% c("t_nostopnopax","t_decel_phase")) %>%  #shouldn't see "t_nopax" at all
  group_by(busrun, seg_name_id) %>%
  summarize(
            delay_source = paste0(unique(stop_area_phase), collapse =","),
            tot_secs = sum(secs_marg, na.rm = TRUE),
            tot_odom_ft = sum(odom_ft_marg, na.rm = TRUE)) %>%
  ungroup() %>%
  left_join(freeflow_to_join, by = "seg_name_id") %>%
  mutate(freeflow_secs = tot_odom_ft / freeflow_fps,
         misc_delay_secs = tot_secs - freeflow_secs) %>%
  select(busrun, 
         seg_name_id,
         delay_source,
         freeflow_secs,
         misc_delay_secs)

# TODO: rename to accel time, modify some of this
stop_time <-
  rawnav_stop_area %>%
  group_by(busrun, seg_name_id) %>%
  filter(!any(stop_area_phase %in% c("t_nostopnopax","t_nopax"))) %>%
  mutate(decelaccel = stop_area_phase %in% c(#"t_decel_phase", #TODO: update this to be accel only?
                                             "t_accel_phase")) %>%
  filter(decelaccel) %>%
  group_by(busrun, seg_name_id) %>%
  summarize(tot_stopping_secs = sum(secs_marg, na.rm = TRUE),
            tot_stopping_odom_ft = sum(odom_ft_marg, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(stopping_fps = tot_stopping_odom_ft / tot_stopping_secs) 

low_stop_time_distr <-
  stop_time %>%
  group_by(seg_name_id) %>%
  summarize(distr = list(quantile(stopping_fps, probs = c(.02,.05,.1,.25,.5,.75,.9,.95,.98)))) 

low_stop_time_to_join <- 
  low_stop_time_distr %>%
  unnest_longer(col = distr,
                values_to = "stopping_fps",
                indices_to  = "ntile") %>%
  filter(ntile == "95%") %>%
  select(seg_name_id, 
         low_stopping_fps = stopping_fps)

stop_time2 <-
  stop_time %>%
  left_join(low_stop_time_to_join, by = "seg_name_id") %>%
  mutate(lowstopping_secs = tot_stopping_odom_ft / low_stopping_fps,
         queue_delay_secs = tot_stopping_secs - lowstopping_secs)

# bring it all together
stop_pass_decomp_1 <- 
  rawnav_stop_area %>%
  # Though we're not expecting to find other values in this category, we'll 
  # be a little careful still
  group_by(busrun, seg_name_id) %>%
  # filter(!any(stop_area_phase %in% c("t_nostop"))) %>%  # TODO: drop this later?
  group_by(busrun, seg_name_id, stop_area_phase) %>%
  summarize(tot_secs = sum(secs_marg, na.rm = TRUE)) %>%
  ungroup() %>%
  pivot_wider(names_from = "stop_area_phase", values_from = "tot_secs") %>%
  rowwise() %>%
  mutate(tot_secs =
           sum(
           t_decel_phase, 
           t_l_initial,
           t_stop1,
           t_stop,
           t_l_addl,
           t_accel_phase,
           t_nostopnopax,
           na.rm = TRUE
           )) %>%
  ungroup() %>%
  select(busrun,
         seg_name_id,
         t_decel_phase,
         t_l_initial,
         t_stop1,
         t_stop,
         t_l_addl,
         t_accel_phase,
         t_nostopnopax,
         tot_secs)

stop_pass_decomp_2 <-
  stop_pass_decomp_1 %>%
  left_join(no_stop_decomp, by = c("busrun","seg_name_id")) %>%
  left_join(stop_time2, by = c("busrun","seg_name_id")) 

stop_pass_decomp_3 <-
  stop_pass_decomp_2 %>%
  mutate(ts_approach_min = freeflow_secs,
         tr_approach_delay = misc_delay_secs,
         tr_init_wait = t_l_initial,
         #TODO: fix
         tr_stop1 = (if_else(is.na(t_stop),0,t_stop) + if_else(is.na(t_stop1),0,t_stop1)),
         tr_signal_wait = t_l_addl,
         ts_accel_min = lowstopping_secs,
         tr_accel_delay = queue_delay_secs
         ) %>%
  rowwise() %>%
  mutate(tot_secs_check = 
           sum(
             ts_approach_min, 
             tr_approach_delay,
             tr_init_wait,
             tr_stop1,
             tr_signal_wait,
             ts_accel_min,
             tr_accel_delay,
             na.rm = TRUE)
  ) %>%
  ungroup() %>%
  mutate(
    tot_secs_check = round(tot_secs_check),
    checksout = tot_secs == tot_secs_check
    )
  
# TODO: 
# Test that the 
testthat::test_that("check sum matches for everything",{
  # TODO: go fix
  doesnt_checkout <-
    stop_pass_decomp_3 %>%
    filter(!checksout)
  
  testthat::expect_true(nrow(doesnt_checkout) == 0)
})

```


# Create Charts
```{r}
decomp_stack <- 
  function(decomp){
  # set cols
    ltblue = "#A6CEE3"
    dkblue = "#1F78B4"
    ltgrn = "#B2DF8A"
    dkgrn = "#33A02C"
    ltred = "#FB9A99"
    dkred = "#E31A1C"
    ltorg = "#FDBF6F"
    dkorg = "#FF7F00"  
    # browser()
  # data check
  chartdata <-
    decomp %>%
    select(
      busrun,
      seg_name_id,
      ts_approach_min,
      tr_approach_delay,
      tr_init_wait,
      tr_stop1,
      tr_signal_wait,
      ts_accel_min,
      tr_accel_delay
    ) %>%
    pivot_longer(
      names_to = "decomp_state",
      values_to = "secs",
      cols = ts_approach_min:tr_accel_delay
    ) %>%
    mutate(secs = round(secs,0),
           decomp_state = 
             factor(decomp_state,
                    levels = c("ts_approach_min",
                               "tr_approach_delay",
                               "tr_init_wait",
                               "tr_stop1",
                               "tr_signal_wait",
                               "ts_accel_min",
                               "tr_accel_delay")),
           source = if_else(decomp_state %in% c("ts_approach_min",
                                                "ts_accel_min"),
                            "Segment-level",
                            "Run-level")
    ) 

  # make cahrt
    ggplot(chartdata,
           aes(x = busrun,
               y = secs, 
               group = busrun, 
               fill = decomp_state,
               color = source,
               label = secs)) + 
      geom_col(size = 1) + 
      geom_label(position = position_stack(vjust = .5)) +
      scale_fill_manual(
        values = c(
        "ts_approach_min" = dkred,
        "tr_approach_delay" = ltred,
        "tr_init_wait" = ltblue, 
        "tr_stop1" = dkblue,
        "tr_signal_wait" = ltorg,
        "ts_accel_min" = dkgrn,
        "tr_accel_delay" = ltgrn
        )
      ) + 
      scale_color_manual(
        values = c("Segment-level" = "black",
                   "Run-level" = "#6a3d9a" )
      ) +
      guides(color = guide_legend(reverse = TRUE)) +
      labs(y = "Seconds")
    
  }

doublecheck <- function(case, seg){

  dc <- 
    stop_pass_decomp_3 %>%
    filter(busrun == case, seg_name_id == seg) %>%
    decomp_stack()
  
  ts <- rawnav_stop_area %>%
    filter(busrun == case, seg_name_id == seg) %>%
    make_basic_timespace()
  
  sd <- rawnav_stop_area %>%
    filter(busrun == case, seg_name_id == seg) %>%
    make_basic_speeddist(alpha = .5, 
                         size = 1.5, 
                         lt = "solid",
                         legend = "none")
  
  ((ts / sd) | dc) +
    plot_annotation(glue::glue("{seg}: Results for run {case}"))
}

# DEBUG SPEED STUFF
# case <- "rawnav03235191030.txt_26551"
# case <- "rawnav03259191029.txt_28005"
# case <- "rawnav03232191024.txt_9587"
# 

stop_pass_decomp_3 %>%
  filter(busrun == "rawnav03232191024.txt_9587") %>%
  filter(seg_name_id == first(seg_name_id)) %>%
  decomp_stack


```



# Export Charts
```{r}

frame <-
  rawnav_stop_area %>%
  distinct(busrun, seg_name_id) %>%
  sample_n(size = 500) %>%
  mutate(
    busrunshow = str_replace(busrun, '\\.txt', 'txt'),
    filename = glue::glue("{seg_name_id}_{busrunshow}.png"),
    plot = pmap(list(busrun, seg_name_id),
                doublecheck)
  )

height = 7
asp = 1.6

frame %>%
  select(filename,
         plot) %>%
  pwalk(.,
        ggsave,
        path = file.path(path_project,'data','01-interim','images'),
        width = height * asp,
        height = height,
        units = "in",
        scale = .9,
        dpi = 300)
```

