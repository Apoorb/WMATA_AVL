---
title: "WMATA Queue Jump Effectiveness: Decomposition Using Separate Accel/Decel, Min+Delay Method"
output: 
  html_notebook:
    toc: true
    toc_depth: 2
    toc_float: yes
    df_print: paged
    number_sections: false
    theme: simplex
---

This notebook illustrates a possible decomposition of travel time focused on separate accel/decel speeds to illustrate the minimum and maximum of each.

We load the same data as the decomposition early-look notebook.
```{r message=FALSE, warning=FALSE}
source("./decomposition-prep.R")
source("./decomposition-sep-accel-decel-calcs.R")

tt_decomp <-
  read_csv(file = file.path(path_data,
                            "traveltime_decomp.csv")) %>%
  select(-X1, -index)
```

In both cases, let's filter out cases where t_traffic seems too long, then ensure both have same values. Not clear why the number of cases differs -- will have to look at our funnel a bit more closely.
```{r}
tt_decomp_fil <-
  tt_decomp %>%
  filter(t_traffic < 500) %>%
  unite(busrun, filename, index_run_start) %>%
  semi_join(stop_pass_decomp_4, by = c("busrun", "seg_name_id"))
  
ad_decomp_fil <-
  stop_pass_decomp_4 %>%
  semi_join(tt_decomp_fil, by = c("busrun", "seg_name_id")) %>%
  mutate_if(is.numeric, ~ replace_na(., 0)) %>%
  group_by(seg_name_id) %>%
  mutate(
    avg_approach_delay = mean(ts_approach_min + tr_approach_delay, na.rm = TRUE),
    avg_accel_delay = mean(ts_accel_min + tr_accel_delay, na.rm = TRUE),
  ) %>%
  mutate(
    t_qj_related =
      subsegment_delay_sec_after_stop_area +
      tr_accel_delay,
    t_ad_decomp_secs_total =
      tot_secs_check +
      subsegment_min_sec_after_stop_area +
      subsegment_min_sec_before_stop_area +
      subsegment_delay_sec_after_stop_area +
      subsegment_delay_sec_before_stop_area
  )

```

Create a comparison df
```{r}
compare_df <-
  tt_decomp_fil %>%
  select(
    busrun,
    seg_name_id,
    route,
    wday,
    start_date_time,
    t_stop1,
    t_ff,
    t_stop2,
    t_stop1,
    t_traffic,
    secs_seg_total
  ) %>%
  left_join(
    {select(ad_decomp_fil,
           busrun,
           seg_name_id,
           ts_approach_min:subsegment_delay_sec_before_stop_area,
           t_qj_related) %>%
     select(-ts_nostop_min,
            -tr_nostop_delay,
            -checksout)
    },
    by = c("busrun","seg_name_id"),
    suffix = c("_tt","_ad")
  )

```

First, let's check that t_stop1 is same in both cases
```{r}
testthat::test_that("tstop1 matches",{
  test_bad_t_stop1 <-
    compare_df %>%
    mutate(t_stop1_check = t_stop1 == tr_stop1) %>%
    filter(!t_stop1_check)
  
  testthat::expect_equal(nrow(test_bad_t_stop1),0)
})

testthat::test_that("sum matches",{
  test_total <-
    compare_df %>%
    mutate(total_diff = secs_seg_total - 
             (tot_secs_check + 
              subsegment_min_sec_after_stop_area +
              subsegment_min_sec_before_stop_area +
              subsegment_delay_sec_after_stop_area +
              subsegment_delay_sec_before_stop_area)) %>%
    filter(total_diff != 0)
})

```

It looks like for a range of t_qj_rlated valeus, there's a wide range of traffic related values. For instance, at 100 seconds of t_qj_delay, we can get as much as 300 seconds of t_traffic. Before we dive in, we'll look at a few other instances. Notably, both have some below-zero values. It also appears that differences may be smaller over longer segments as the effect of areas outside the segment dwarf the differences near the stop area.
```{r}
gg <- compare_df %>%
  plotly::highlight_key(., ~busrun) %>%
  ggplot(., aes(x = t_qj_related,
                y = t_traffic)) +
  geom_point() 

# gg %>% ggplotly()

gg
```
In general though, they're pretty similar. R2 is nearly 90%
```{r}
cor(compare_df$t_qj_related, compare_df$t_traffic)
```


Looking by segment, nothing immediately jumps out, but the markers for irving_fifteenth_sixteenth obscure the others somewhat.
```{r}
gg2 <- compare_df %>%
  plotly::highlight_key(., ~busrun) %>%
  ggplot(., aes(x = t_qj_related,
                y = t_traffic, 
                color = seg_name_id)) +
  geom_point(
         alpha = .2,
         shape = 21,
         fill = NA
  ) 

gg2
```

What if we filter to weekday PM peak?

```{r}
compare_df_pmpeak <-
  compare_df %>%
  filter(!(wday %in% c("Saturday","Sunday")), 
         lubridate::hour(start_date_time) >= 16, 
         lubridate::hour(start_date_time) < 17)

gg3 <- compare_df_pmpeak %>%
  plotly::highlight_key(., ~busrun) %>%
  ggplot(., aes(x = t_qj_related,
                y = t_traffic, 
                color = seg_name_id)) +
  geom_point(
         alpha = .2,
         shape = 21,
         fill = NA
  ) 

gg3
```

Let's look at a few particular cases before we dive into an explanation. Here's one that has about 154 secs related to queue jump under a/d version, but 303 seconds of t_traffic. A big diff seems to be the 71 seconds delay before arriving at a stop (subsegment_delay_sec_before_stop_area). That still leaves about 80 seconds of delay in t_traffic not captured in the a/d version.

Notably, the minimum time in the stop area in the a/d approach is 8.74 + 11 seconds, or about 20 seconds. t_stop2 is assumed as 14 seconds, so an addition 6 seconds there goes to t_traffic. 

One could also say the t_init_wait isn't covered in a/d appraoch, but that's zero here. 

```{r}
compare_df %>%
  filter(busrun == "rawnav06466191024.txt_14003") %>% 
  base::t()

```

```{r}
x <- doublecheck("rawnav06466191024.txt_14003", "sixteenth_u_long")
```



This additional time could be a few things:
- upstream delay from a stop
- delay opening doors before serving passengers

Note that the fact that t_traffic values are higher are 'offset' in one way -- t_accel_delay is likely lower than the difference in 
